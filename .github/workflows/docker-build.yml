name: Build and Push Docker Image

on:
  # Run on push to main branches and manual trigger
  push:
    branches: [ main, master, v0.0.3a ]
  # Allow manual triggering
  workflow_dispatch:

env:
  REGISTRY: docker.io
  IMAGE_NAME: mck3dprintfarm

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      # Set up QEMU for cross-platform builds
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2
        with:
          platforms: 'arm64,amd64'

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      # Extract version from package.json
      - name: Extract version from package.json
        id: package-version
        run: |
          VERSION=$(grep '"version"' package.json | cut -d '"' -f 4)
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version extracted: $VERSION"

      # Create special build versions of files for GitHub Actions
      - name: Prepare build environment
        run: |
          echo "Creating a GitHub-specific Dockerfile..."
          cp Dockerfile Dockerfile.original
          
          # Create a modified Dockerfile that forces installation of all UI dependencies
          cat > Dockerfile << 'EOF'
          # Use Node.js 18 Alpine as the base image for the build stage
          FROM node:18-alpine AS builder

          # Set the working directory
          WORKDIR /app

          # Copy package files
          COPY package*.json ./
          COPY .npmrc ./

          # Install all dependencies properly and ensure UI libraries are available
          RUN npm ci && \
              npm install --no-save --legacy-peer-deps lucide-react @radix-ui/react-icons @radix-ui/react-slot @radix-ui/react-tabs @radix-ui/react-toast class-variance-authority tailwind-merge && \
              npm cache clean --force

          # Copy the source code
          COPY . .

          # Fix path resolution issues - explicit symlinks for key components
          RUN echo "Fixing path resolution by creating explicit aliases..." && \
              mkdir -p /app/node_modules/@/components && \
              ln -s /app/src/components /app/node_modules/@/components && \
              mkdir -p /app/node_modules/@/lib && \
              ln -s /app/src/lib /app/node_modules/@/lib && \
              mkdir -p /app/node_modules/@/app && \
              ln -s /app/src/app /app/node_modules/@/app
          
          # Add explicit use client directives to all components that might need it
          RUN echo 'Adding "use client" directive to components that might need it...' && \
              find src/components -name "*.tsx" -exec sh -c 'if ! grep -q "use client" {}; then sed -i "1s/^/\"use client\";\n\n/" {}; fi' \; && \
              find src/components -name "*.ts" -exec sh -c 'if ! grep -q "use client" {}; then sed -i "1s/^/\"use client\";\n\n/" {}; fi' \;

          # Generate Prisma client
          RUN npx prisma generate

          # Create a special .env file for the build process
          RUN echo "NEXT_PUBLIC_BUILD_ENV=production" > .env

          # Set NODE_ENV to production for the build
          ENV NODE_ENV=production

          # Build the Next.js application with direct path for static exports
          RUN NEXT_TELEMETRY_DISABLED=1 NODE_OPTIONS="--max-old-space-size=4096" npm run build && npm prune --production && npm cache clean --force

          # Production image - use a smaller footprint
          FROM node:18-alpine AS runner

          WORKDIR /app

          # Create uploads directory
          RUN mkdir -p uploads

          # Set environment variables
          ENV DOCKER_ENV=true
          ENV NODE_ENV=production

          # Copy only what's needed from builder
          COPY --from=builder /app/.next/standalone ./
          COPY --from=builder /app/.next/static ./.next/static
          COPY --from=builder /app/public ./public
          COPY --from=builder /app/scripts ./scripts
          COPY --from=builder /app/prisma ./prisma
          COPY --from=builder /app/node_modules/.prisma ./node_modules/.prisma
          COPY --from=builder /app/node_modules/@prisma ./node_modules/@prisma
          COPY --from=builder /app/package.json ./package.json

          # Install necessary tools including sqlite3 for direct db access
          RUN apk add --no-cache sqlite && \
              apk add --no-cache --virtual .gyp python3 make g++ && \
              mkdir -p /tmp/npm-tmp && \
              npm config set cache /tmp/npm-tmp && \
              npm install -g prisma --no-optional && \
              npm install bcryptjs && \
              apk del .gyp && \
              rm -rf /tmp/npm-tmp

          # Create startup script with improved Prisma migration handling
          RUN echo '#!/bin/sh' > /app/docker-entrypoint.sh && \
              echo 'set -e' >> /app/docker-entrypoint.sh && \
              echo 'echo "Running Prisma generate with local schema..."' >> /app/docker-entrypoint.sh && \
              echo 'cd /app && npx prisma generate' >> /app/docker-entrypoint.sh && \
              echo 'echo "Checking if database exists and is initialized..."' >> /app/docker-entrypoint.sh && \
              echo 'cd /app && npx prisma db push --accept-data-loss --skip-generate' >> /app/docker-entrypoint.sh && \
              echo 'echo "Applying migrations if needed..."' >> /app/docker-entrypoint.sh && \
              echo 'cd /app && npx prisma migrate deploy --schema=./prisma/schema.prisma' >> /app/docker-entrypoint.sh && \
              echo 'echo "Directly creating tables with SQLite..."' >> /app/docker-entrypoint.sh && \
              echo 'DB_PATH=$(grep -o "file:.*" ./prisma/schema.prisma | cut -d\" -f2)' >> /app/docker-entrypoint.sh && \
              echo 'echo "Database path: $DB_PATH"' >> /app/docker-entrypoint.sh && \
              echo 'if [ -f "./prisma/$DB_PATH" ]; then' >> /app/docker-entrypoint.sh && \
              echo '  echo "Database file exists, executing ensure_tables.sql..."' >> /app/docker-entrypoint.sh && \
              echo '  sqlite3 "./prisma/$DB_PATH" < ./prisma/ensure_tables.sql' >> /app/docker-entrypoint.sh && \
              echo 'else' >> /app/docker-entrypoint.sh && \
              echo '  echo "Database file does not exist at ./prisma/$DB_PATH"' >> /app/docker-entrypoint.sh && \
              echo '  ls -la ./prisma/' >> /app/docker-entrypoint.sh && \
              echo 'fi' >> /app/docker-entrypoint.sh && \
              echo 'echo "Creating admin user if needed..."' >> /app/docker-entrypoint.sh && \
              echo 'node /app/scripts/create-admin-user.js' >> /app/docker-entrypoint.sh && \
              echo 'echo "Starting server..."' >> /app/docker-entrypoint.sh && \
              echo 'node server.js' >> /app/docker-entrypoint.sh && \
              chmod +x /app/docker-entrypoint.sh

          # Expose port
          EXPOSE 3000

          # Start the application
          CMD ["/app/docker-entrypoint.sh"]
          EOF
          
          echo "Created GitHub-specific Dockerfile."
          
          # Create .npmrc file
          echo "Creating .npmrc file..."
          cat > .npmrc << 'EOF'
          legacy-peer-deps=true
          node-linker=hoisted
          fetch-retries=5
          fetch-retry-mintimeout=20000
          fetch-retry-maxtimeout=120000
          network-timeout=300000
          save-exact=true
          EOF
          
          # Check if printer-skeleton.tsx exists and print its path for debugging
          if [ -f "src/components/printer-skeleton.tsx" ]; then
            echo "printer-skeleton.tsx exists at src/components/printer-skeleton.tsx"
            cat src/components/printer-skeleton.tsx | head -n 5
          else
            echo "printer-skeleton.tsx not found, creating it..."
            mkdir -p src/components
            cat > src/components/printer-skeleton.tsx << 'EOF'
          "use client";
          
          import React from "react";
          import { Card, CardContent, CardFooter, CardHeader } from "@/components/ui/card";
          
          export function PrinterSkeleton() {
            return (
              <Card className="w-full h-full animate-pulse">
                <CardHeader>
                  <div className="flex justify-between items-center">
                    <div className="h-6 bg-gray-200 rounded w-1/3"></div>
                    <div className="h-5 bg-gray-200 rounded w-1/4"></div>
                  </div>
                  <div className="h-4 bg-gray-200 rounded w-1/4 mt-2"></div>
                </CardHeader>
                <CardContent>
                  <div className="space-y-4">
                    {/* Preview area */}
                    <div className="w-full h-32 bg-gray-200 rounded"></div>
                    
                    {/* Temperatures */}
                    <div className="space-y-2">
                      <div className="flex justify-between">
                        <div className="h-4 bg-gray-200 rounded w-1/5"></div>
                        <div className="h-4 bg-gray-200 rounded w-1/5"></div>
                      </div>
                      <div className="flex justify-between">
                        <div className="h-4 bg-gray-200 rounded w-1/5"></div>
                        <div className="h-4 bg-gray-200 rounded w-1/5"></div>
                      </div>
                    </div>
                    
                    {/* Empty space for job status */}
                    <div className="h-24 bg-gray-200 rounded mt-4"></div>
                  </div>
                </CardContent>
                <CardFooter>
                  <div className="h-8 bg-gray-200 rounded w-1/4"></div>
                </CardFooter>
              </Card>
            );
          }
          EOF
          fi
          
          echo "Environment preparation complete."

      # Login to DockerHub
      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # Get Docker username in correct format
      - name: Prepare Docker Hub username
        id: prep
        run: |
          DOCKER_USER="${{ secrets.DOCKERHUB_USERNAME }}"
          # Convert username to lowercase and remove special characters
          SANITIZED_USER=$(echo "$DOCKER_USER" | tr '[:upper:]' '[:lower:]' | tr -cd '[:alnum:]_.-')
          echo "sanitized_user=$SANITIZED_USER" >> $GITHUB_OUTPUT
          echo "Using Docker Hub username: $SANITIZED_USER"
          
          # Full image name
          FULL_IMAGE_NAME="$SANITIZED_USER/${{ env.IMAGE_NAME }}"
          echo "full_image_name=$FULL_IMAGE_NAME" >> $GITHUB_OUTPUT
          echo "Full image name: $FULL_IMAGE_NAME"

      # Build and push multi-platform images using enhanced settings
      - name: Build and push Docker images
        uses: docker/build-push-action@v4
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            ${{ steps.prep.outputs.full_image_name }}:latest
            ${{ steps.prep.outputs.full_image_name }}:${{ steps.package-version.outputs.version }}
          build-args: |
            BUILDKIT_INLINE_CACHE=1
            NODE_ENV=production
            NEXTAUTH_URL=http://localhost:3000
            DATABASE_URL=file:/app/prisma/dev.db
            NEXT_TELEMETRY_DISABLED=1

      # Restore original Dockerfile to avoid committing changes
      - name: Restore original Dockerfile
        run: |
          if [ -f Dockerfile.original ]; then
            mv Dockerfile.original Dockerfile
            echo "Original Dockerfile restored."
          fi
          
      # Final message about success
      - name: Display completion message
        run: |
          echo "Successfully built and pushed multi-architecture Docker images:"
          echo "AMD64: ${{ steps.prep.outputs.full_image_name }}:latest"
          echo "ARM64: ${{ steps.prep.outputs.full_image_name }}:latest"
          echo "AMD64: ${{ steps.prep.outputs.full_image_name }}:${{ steps.package-version.outputs.version }}"
          echo "ARM64: ${{ steps.prep.outputs.full_image_name }}:${{ steps.package-version.outputs.version }}"
          echo ""
          echo "Images can be pulled with: docker pull ${{ steps.prep.outputs.full_image_name }}:latest"

      # Update Docker Hub Description
      # - name: Update Docker Hub Description
      #   uses: peter-evans/dockerhub-description@v3
      #   with:
      #     username: ${{ secrets.DOCKERHUB_USERNAME }}
      #     password: ${{ secrets.DOCKERHUB_TOKEN }}
      #     repository: ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}
      #     short-description: "McKinnon Secondary College 3D Print Farm management application" 